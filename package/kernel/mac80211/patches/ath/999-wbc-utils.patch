--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -150,6 +150,36 @@ struct ath_common {
 	enum ath_device_state state;
 	unsigned long op_flags;
 	u32 chan_bw;
+	
+	// txpower custom switch 
+	u8 txpower_custom;
+	// txpower in dBm
+	u8 txpower_b_high;
+	u8 txpower_b_low;
+	u8 txpower_b_rate;
+	u8 txpower_g_high;
+	u8 txpower_g_low;
+	u8 txpower_g_rate;
+	u8 txpower_n_high;
+	u8 txpower_n_low;
+	u8 txpower_n_rate;
+	// txpower debug
+	u8 txpower_debug;
+
+	// Ant. Diversity custom
+	u8 ant_div_ctl;
+	u8 ant_custom_en;
+
+	// channel frequency custom
+	u8 chanfreq_en;
+	u32 chanfreq;
+
+	// mac hacks: slottime, thresh62, aifs, sifs
+	u8 mac_hack_en;
+	u8 aifs_man;
+	u8 slottime_man;
+	u8 thresh62_man;
+	u8 sifs_man;
 
 	struct ath_ani ani;
 
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3732,6 +3732,8 @@ static void ar9003_hw_ant_ctrl_apply(str
 		/* enable_lnadiv */
 		regval &= (~AR_PHY_ANT_DIV_LNADIV);
 		regval |= ((value >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;
+		if ((1 == common->ant_custom_en) && (common->ant_div_ctl & 0x10))
+			regval |= 1 << AR_PHY_ANT_DIV_LNADIV_S;
 
 		if (AR_SREV_9485(ah) && common->bt_ant_diversity)
 			regval |= AR_ANT_DIV_ENABLE;
@@ -3770,6 +3772,9 @@ static void ar9003_hw_ant_ctrl_apply(str
 		    && common->bt_ant_diversity)
 			regval |= AR_FAST_DIV_ENABLE;
 
+		if ((1 == common->ant_custom_en) && (common->ant_div_ctl & 0x80))
+			regval |= AR_FAST_DIV_ENABLE;
+
 		REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);
 
 		if (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {
@@ -3782,11 +3787,24 @@ static void ar9003_hw_ant_ctrl_apply(str
 				     AR_PHY_ANT_DIV_ALT_LNACONF |
 				     AR_PHY_ANT_DIV_ALT_GAINTB |
 				     AR_PHY_ANT_DIV_MAIN_GAINTB));
-			/* by default use LNA1 for the main antenna */
-			regval |= (ATH_ANT_DIV_COMB_LNA1 <<
-				   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
-			regval |= (ATH_ANT_DIV_COMB_LNA2 <<
-				   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+			if (1 == common->ant_custom_en) {
+				regval |= (common->ant_div_ctl & 0x40)? 
+					(AR_PHY_ANT_DIV_MAIN_GAINTB << AR_PHY_ANT_DIV_MAIN_GAINTB_S): 0;
+				regval |= (common->ant_div_ctl & 0x20)? 
+					(AR_PHY_ANT_DIV_ALT_GAINTB << AR_PHY_ANT_DIV_ALT_GAINTB_S): 0;
+				regval |= (common->ant_div_ctl & 0x0C)? 
+					(AR_PHY_ANT_DIV_MAIN_LNACONF << AR_PHY_ANT_DIV_MAIN_LNACONF_S): 0;
+				regval |= (common->ant_div_ctl & 0x03)? 
+					(AR_PHY_ANT_DIV_ALT_LNACONF << AR_PHY_ANT_DIV_ALT_LNACONF_S): 0;
+			} else {
+				
+				/* by default use LNA1 for the main antenna */
+				regval |= (ATH_ANT_DIV_COMB_LNA1 <<
+					   AR_PHY_ANT_DIV_MAIN_LNACONF_S);
+				regval |= (ATH_ANT_DIV_COMB_LNA2 <<
+					   AR_PHY_ANT_DIV_ALT_LNACONF_S);
+				
+			}
 			REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);
 		}
 	}
@@ -4204,6 +4222,7 @@ static void ar9003_hw_apply_minccapwr_th
 					     bool is2ghz)
 {
 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+	struct ath_common *common = ath9k_hw_common(ah);
 	const u_int32_t cca_ctrl[AR9300_MAX_CHAINS] = {
 		AR_PHY_CCA_CTRL_0,
 		AR_PHY_CCA_CTRL_1,
@@ -4225,8 +4244,15 @@ static void ar9003_hw_apply_minccapwr_th
 			continue;
 
 		val = ar9003_modal_header(ah, is2ghz)->noiseFloorThreshCh[chain];
-		REG_RMW_FIELD(ah, cca_ctrl[chain],
+		if (common->mac_hack_en == 1 && common->thresh62_man != 0) {
+			REG_RMW_FIELD(ah, cca_ctrl[chain],
+			      AR_PHY_EXT_CCA0_THRESH62_1, common->thresh62_man);
+			printk("ar9003_eeprom: custom thresh62 set %d on chain %d\n", 
+							common->thresh62_man, chain);
+		} else {
+			REG_RMW_FIELD(ah, cca_ctrl[chain],
 			      AR_PHY_EXT_CCA0_THRESH62_1, val);
+		}
 	}
 
 }
@@ -5234,7 +5260,7 @@ static void ar9003_hw_set_power_per_rate
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ar9300_eeprom *pEepData = &ah->eeprom.ar9300_eep;
 	u16 twiceMaxEdgePower;
-	int i;
+	int i, j;
 	u16 scaledPower = 0, minCtlPower;
 	static const u16 ctlModesFor11a[] = {
 		CTL_11A, CTL_5GHT20, CTL_11A_EXT, CTL_5GHT40
@@ -5251,157 +5277,270 @@ static void ar9003_hw_set_power_per_rate
 	u8 ctlNum;
 	u16 twiceMinEdgePower;
 	bool is2ghz = IS_CHAN_2GHZ(chan);
+	u8 txp_bl, txp_bh, txp_gl, txp_gh, txp_nl, txp_nh;
 
 	ath9k_hw_get_channel_centers(ah, chan, &centers);
 	scaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,
 						antenna_reduction);
-
-	if (is2ghz) {
-		/* Setup for CTL modes */
-		/* CTL_11B, CTL_11G, CTL_2GHT20 */
-		numCtlModes =
-			ARRAY_SIZE(ctlModesFor11g) -
-				   SUB_NUM_CTL_MODES_AT_2G_40;
-		pCtlMode = ctlModesFor11g;
-		if (IS_CHAN_HT40(chan))
-			/* All 2G CTL's */
-			numCtlModes = ARRAY_SIZE(ctlModesFor11g);
+	
+	if (common->txpower_custom == 1) {
+		// Use custom txpower					
+		// dBm to reg value
+		txp_bl = common->txpower_b_low * 2;
+		txp_bh = common->txpower_b_high * 2;
+		txp_gl = common->txpower_g_low * 2;
+		txp_gh = common->txpower_g_high * 2;
+		txp_nl = common->txpower_n_low * 2;
+		txp_nh = common->txpower_n_high * 2;	
+		
+		// set 802.11b power
+		for (i = ALL_TARGET_LEGACY_1L_5L; i <= ALL_TARGET_LEGACY_11S; i++) {
+			pPwrArray[i] = txp_bl;
+		}
+		switch (common->txpower_b_rate) {
+		case 11:
+			pPwrArray[ALL_TARGET_LEGACY_11S] = txp_bh;
+			pPwrArray[ALL_TARGET_LEGACY_11L] = txp_bh;
+		case 5:
+		case 2:
+		case 1:
+			pPwrArray[ALL_TARGET_LEGACY_5S] = txp_bh;
+			pPwrArray[ALL_TARGET_LEGACY_1L_5L] = txp_bh;
+			break;
+		}
+		// 802.11g power
+		for (i = ALL_TARGET_LEGACY_6_24; i <= ALL_TARGET_LEGACY_54; i++) {
+			pPwrArray[i] = txp_gl;
+		}
+		switch (common->txpower_g_rate) {
+		case 54: 
+			pPwrArray[ALL_TARGET_LEGACY_54] = txp_gh;
+		case 48: 
+			pPwrArray[ALL_TARGET_LEGACY_48] = txp_gh;
+		case 36: 
+			pPwrArray[ALL_TARGET_LEGACY_36] = txp_gh;
+		case 24: 
+		case 18: 
+		case 12: 
+		case 9: 
+		case 6: 
+			pPwrArray[ALL_TARGET_LEGACY_6_24] = txp_gh; 
+			break;
+		}
+		// 802.11n HT20 power
+		for (i = ALL_TARGET_HT20_0_8_16; i <= ALL_TARGET_HT20_23; i++) {
+			pPwrArray[i] = txp_nl;
+		}
+		switch (common->txpower_n_rate) {
+		case 7: 
+			pPwrArray[ALL_TARGET_HT20_23] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_15] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_7] = txp_nh;
+		case 6: 
+			pPwrArray[ALL_TARGET_HT20_22] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_14] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_6] = txp_nh;
+		case 5: 
+			pPwrArray[ALL_TARGET_HT20_21] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_13] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_5] = txp_nh;
+		case 4: 
+			pPwrArray[ALL_TARGET_HT20_20] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_12] = txp_nh;
+			pPwrArray[ALL_TARGET_HT20_4] = txp_nh;
+		case 3: 
+		case 2: 
+		case 1: 
+			pPwrArray[ALL_TARGET_HT20_1_3_9_11_17_19] = txp_nh;
+		case 0: 
+			pPwrArray[ALL_TARGET_HT20_0_8_16] = txp_nh; 
+			break;
+		}	
+		// others (ht40): use 802.11n's low power as default
+		for (i = ALL_TARGET_HT40_0_8_16; i <ar9300RateSize ; i++) {
+			pPwrArray[i] = txp_nl;
+		}
+		
+		// print to dmesg
+		printk("ath: ar9003_eeprom: TX Power set: 802.11b: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low);
+		printk("ath: ar9003_eeprom: TX Power set: 802.11g: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low);
+		printk("ath: ar9003_eeprom: TX Power set: 802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+				common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low);
+		//printk("Note: ar9003 uses the same power on b:1,2,5, g:6,9,12,18,24 or n:1,2,3\n");
+		// debug: print pPwrArray
+		if (common->txpower_debug) {
+			printk("ath: ar9003_eeprom: TX Power Debug: pPwrArray[]: \n");
+			for (j=0; j<(ar9300RateSize/8)+1; j++) {
+				for (i=0; i<8; i++) {
+					printk("%d ", pPwrArray[j*8+i]);
+				}
+				printk("\n");
+			}
+		}
+		return;
+		
 	} else {
-		/* Setup for CTL modes */
-		/* CTL_11A, CTL_5GHT20 */
-		numCtlModes = ARRAY_SIZE(ctlModesFor11a) -
-					 SUB_NUM_CTL_MODES_AT_5G_40;
-		pCtlMode = ctlModesFor11a;
-		if (IS_CHAN_HT40(chan))
-			/* All 5G CTL's */
-			numCtlModes = ARRAY_SIZE(ctlModesFor11a);
-	}
-
-	/*
-	 * For MIMO, need to apply regulatory caps individually across
-	 * dynamically running modes: CCK, OFDM, HT20, HT40
-	 *
-	 * The outer loop walks through each possible applicable runtime mode.
-	 * The inner loop walks through each ctlIndex entry in EEPROM.
-	 * The ctl value is encoded as [7:4] == test group, [3:0] == test mode.
-	 */
-	for (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {
-		bool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||
-			(pCtlMode[ctlMode] == CTL_2GHT40);
-		if (isHt40CtlMode)
-			freq = centers.synth_center;
-		else if (pCtlMode[ctlMode] & EXT_ADDITIVE)
-			freq = centers.ext_center;
-		else
-			freq = centers.ctl_center;
-
-		ath_dbg(common, REGULATORY,
-			"LOOP-Mode ctlMode %d < %d, isHt40CtlMode %d, EXT_ADDITIVE %d\n",
-			ctlMode, numCtlModes, isHt40CtlMode,
-			(pCtlMode[ctlMode] & EXT_ADDITIVE));
-
-		/* walk through each CTL index stored in EEPROM */
+		// Use driver controlled txpower
 		if (is2ghz) {
-			ctlIndex = pEepData->ctlIndex_2G;
-			ctlNum = AR9300_NUM_CTLS_2G;
+			/* Setup for CTL modes */
+			/* CTL_11B, CTL_11G, CTL_2GHT20 */
+			numCtlModes =
+				ARRAY_SIZE(ctlModesFor11g) -
+				   	SUB_NUM_CTL_MODES_AT_2G_40;
+			pCtlMode = ctlModesFor11g;
+			if (IS_CHAN_HT40(chan))
+				/* All 2G CTL's */
+				numCtlModes = ARRAY_SIZE(ctlModesFor11g);
 		} else {
-			ctlIndex = pEepData->ctlIndex_5G;
-			ctlNum = AR9300_NUM_CTLS_5G;
+			/* Setup for CTL modes */
+			/* CTL_11A, CTL_5GHT20 */
+			numCtlModes = ARRAY_SIZE(ctlModesFor11a) -
+					 	SUB_NUM_CTL_MODES_AT_5G_40;
+			pCtlMode = ctlModesFor11a;
+			if (IS_CHAN_HT40(chan))
+				/* All 5G CTL's */
+				numCtlModes = ARRAY_SIZE(ctlModesFor11a);
 		}
-
-		twiceMaxEdgePower = MAX_RATE_POWER;
-		for (i = 0; (i < ctlNum) && ctlIndex[i]; i++) {
+	
+		/*
+	 	* For MIMO, need to apply regulatory caps individually across
+	 	* dynamically running modes: CCK, OFDM, HT20, HT40
+	 	*
+	 	* The outer loop walks through each possible applicable runtime mode.
+	 	* The inner loop walks through each ctlIndex entry in EEPROM.
+	 	* The ctl value is encoded as [7:4] == test group, [3:0] == test mode.
+	 	*/
+		for (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {
+			bool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||
+				(pCtlMode[ctlMode] == CTL_2GHT40);
+			if (isHt40CtlMode)
+				freq = centers.synth_center;
+			else if (pCtlMode[ctlMode] & EXT_ADDITIVE)
+				freq = centers.ext_center;
+			else
+				freq = centers.ctl_center;
+	
 			ath_dbg(common, REGULATORY,
-				"LOOP-Ctlidx %d: cfgCtl 0x%2.2x pCtlMode 0x%2.2x ctlIndex 0x%2.2x chan %d\n",
-				i, cfgCtl, pCtlMode[ctlMode], ctlIndex[i],
-				chan->channel);
-
-			/*
-			 * compare test group from regulatory
-			 * channel list with test mode from pCtlMode
-			 * list
-			 */
-			if ((((cfgCtl & ~CTL_MODE_M) |
-			       (pCtlMode[ctlMode] & CTL_MODE_M)) ==
-				ctlIndex[i]) ||
-			    (((cfgCtl & ~CTL_MODE_M) |
-			       (pCtlMode[ctlMode] & CTL_MODE_M)) ==
-			     ((ctlIndex[i] & CTL_MODE_M) |
-			       SD_NO_CTL))) {
-				twiceMinEdgePower =
-				  ar9003_hw_get_max_edge_power(pEepData,
-							       freq, i,
-							       is2ghz);
-
-				if ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL)
-					/*
-					 * Find the minimum of all CTL
-					 * edge powers that apply to
-					 * this channel
-					 */
-					twiceMaxEdgePower =
-						min(twiceMaxEdgePower,
-						    twiceMinEdgePower);
-				else {
-					/* specific */
-					twiceMaxEdgePower = twiceMinEdgePower;
-					break;
+				"LOOP-Mode ctlMode %d < %d, isHt40CtlMode %d, EXT_ADDITIVE %d\n",
+				ctlMode, numCtlModes, isHt40CtlMode,
+				(pCtlMode[ctlMode] & EXT_ADDITIVE));
+	
+			/* walk through each CTL index stored in EEPROM */
+			if (is2ghz) {
+				ctlIndex = pEepData->ctlIndex_2G;
+				ctlNum = AR9300_NUM_CTLS_2G;
+			} else {
+				ctlIndex = pEepData->ctlIndex_5G;
+				ctlNum = AR9300_NUM_CTLS_5G;
+			}
+	
+			twiceMaxEdgePower = MAX_RATE_POWER;
+			for (i = 0; (i < ctlNum) && ctlIndex[i]; i++) {
+				ath_dbg(common, REGULATORY,
+					"LOOP-Ctlidx %d: cfgCtl 0x%2.2x pCtlMode 0x%2.2x ctlIndex 0x%2.2x chan %d\n",
+					i, cfgCtl, pCtlMode[ctlMode], ctlIndex[i],
+					chan->channel);
+	
+				/*
+			 	* compare test group from regulatory
+			 	* channel list with test mode from pCtlMode
+			 	* list
+			 	*/
+				if ((((cfgCtl & ~CTL_MODE_M) |
+			       	(pCtlMode[ctlMode] & CTL_MODE_M)) ==
+					ctlIndex[i]) ||
+			    	(((cfgCtl & ~CTL_MODE_M) |
+			       	(pCtlMode[ctlMode] & CTL_MODE_M)) ==
+			     	((ctlIndex[i] & CTL_MODE_M) |
+			       	SD_NO_CTL))) {
+					twiceMinEdgePower =
+				  	ar9003_hw_get_max_edge_power(pEepData,
+							       	freq, i,
+							       	is2ghz);
+	
+					if ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL)
+						/*
+					 	* Find the minimum of all CTL
+					 	* edge powers that apply to
+					 	* this channel
+					 	*/
+						twiceMaxEdgePower =
+							min(twiceMaxEdgePower,
+						    	twiceMinEdgePower);
+					else {
+						/* specific */
+						twiceMaxEdgePower = twiceMinEdgePower;
+						break;
+					}
 				}
 			}
-		}
-
-		minCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);
-
-		ath_dbg(common, REGULATORY,
-			"SEL-Min ctlMode %d pCtlMode %d 2xMaxEdge %d sP %d minCtlPwr %d\n",
-			ctlMode, pCtlMode[ctlMode], twiceMaxEdgePower,
-			scaledPower, minCtlPower);
-
-		/* Apply ctl mode to correct target power set */
-		switch (pCtlMode[ctlMode]) {
-		case CTL_11B:
-			for (i = ALL_TARGET_LEGACY_1L_5L;
-			     i <= ALL_TARGET_LEGACY_11S; i++)
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-			break;
-		case CTL_11A:
-		case CTL_11G:
-			for (i = ALL_TARGET_LEGACY_6_24;
-			     i <= ALL_TARGET_LEGACY_54; i++)
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-			break;
-		case CTL_5GHT20:
-		case CTL_2GHT20:
-			for (i = ALL_TARGET_HT20_0_8_16;
-			     i <= ALL_TARGET_HT20_23; i++) {
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-				if (ath9k_hw_mci_is_enabled(ah))
-					pPwrArray[i] =
-						(u8)min((u16)pPwrArray[i],
-						ar9003_mci_get_max_txpower(ah,
-							pCtlMode[ctlMode]));
+	
+			minCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);
+	
+			ath_dbg(common, REGULATORY,
+				"SEL-Min ctlMode %d pCtlMode %d 2xMaxEdge %d sP %d minCtlPwr %d\n",
+				ctlMode, pCtlMode[ctlMode], twiceMaxEdgePower,
+				scaledPower, minCtlPower);
+	
+			/* Apply ctl mode to correct target power set */
+			switch (pCtlMode[ctlMode]) {
+			case CTL_11B:
+				for (i = ALL_TARGET_LEGACY_1L_5L;
+			     	i <= ALL_TARGET_LEGACY_11S; i++)
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+				break;
+			case CTL_11A:
+			case CTL_11G:
+				for (i = ALL_TARGET_LEGACY_6_24;
+			     	i <= ALL_TARGET_LEGACY_54; i++)
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+				break;
+			case CTL_5GHT20:
+			case CTL_2GHT20:
+				for (i = ALL_TARGET_HT20_0_8_16;
+			     	i <= ALL_TARGET_HT20_23; i++) {
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+					if (ath9k_hw_mci_is_enabled(ah))
+						pPwrArray[i] =
+							(u8)min((u16)pPwrArray[i],
+							ar9003_mci_get_max_txpower(ah,
+								pCtlMode[ctlMode]));
+				}
+				break;
+			case CTL_5GHT40:
+			case CTL_2GHT40:
+				for (i = ALL_TARGET_HT40_0_8_16;
+			     	i <= ALL_TARGET_HT40_23; i++) {
+					pPwrArray[i] = (u8)min((u16)pPwrArray[i],
+						       	minCtlPower);
+					if (ath9k_hw_mci_is_enabled(ah))
+						pPwrArray[i] =
+							(u8)min((u16)pPwrArray[i],
+							ar9003_mci_get_max_txpower(ah,
+								pCtlMode[ctlMode]));
+				}
+				break;
+			default:
+				break;
 			}
-			break;
-		case CTL_5GHT40:
-		case CTL_2GHT40:
-			for (i = ALL_TARGET_HT40_0_8_16;
-			     i <= ALL_TARGET_HT40_23; i++) {
-				pPwrArray[i] = (u8)min((u16)pPwrArray[i],
-						       minCtlPower);
-				if (ath9k_hw_mci_is_enabled(ah))
-					pPwrArray[i] =
-						(u8)min((u16)pPwrArray[i],
-						ar9003_mci_get_max_txpower(ah,
-							pCtlMode[ctlMode]));
+		} /* end ctl mode checking */
+		
+		// debug: print pPwrArray
+		if (common->txpower_debug) {
+			printk("ath: ar9003_eeprom: TX Power Debug: pPwrArray[]: \n");
+			for (j=0; j<(ar9300RateSize/8)+1; j++) {
+				for (i=0; i<8; i++) {
+					printk("%d ", pPwrArray[j*8+i]);
+				}
+				printk("\n");
 			}
-			break;
-		default:
-			break;
 		}
-	} /* end ctl mode checking */
+	}
 }
 
 static inline u8 mcsidx_to_tgtpwridx(unsigned int mcs_idx, u8 base_pwridx)
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -1565,6 +1565,339 @@ static const struct file_operations fops
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_txpower_custom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[256];
+	unsigned int len;
+
+	len = sprintf(buf,
+		"txpower custom: \n"
+		"802.11b: rate %d Mbps, high %d dBm, low %d dBm\n"
+		"802.11g: rate %d Mbps, high %d dBm, low %d dBm\n"
+		"802.11n: MCS %d, high %d dBm, low %d dBm\n",
+		common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low,
+		common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low,
+		common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low
+	);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_txpower_custom(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	ssize_t len;
+	int i, j, ret, int_rate, int_power_high, int_power_low;
+	char wifi_mode = '\0';
+	u8 rate = 0, power_high = 0, power_low = 0;
+	u8 b_rate_list[] = {1, 2, 5, 11};
+	u8 g_rate_list[] = {6, 9, 12, 18, 24, 36, 48, 54};
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%c:%d:%d:%d",
+					&wifi_mode, &int_rate, &int_power_high, &int_power_low);
+
+	rate = (u8)int_rate;
+	power_high = (u8)int_power_high;
+	power_low = (u8)int_power_low;
+
+	// check input
+	// to-do: rewrite this
+	j = 0;
+	if (wifi_mode == 'b') {
+		// check if the input rate is in b_rate_list[]
+		for (i=0; i<sizeof(b_rate_list); i++) {
+			if (rate == b_rate_list[i]) {
+				j = 1;
+				break;
+			}
+		}
+		if (j == 0) {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 'g') {
+		for (i=0; i<sizeof(g_rate_list); i++) {
+			if (rate == g_rate_list[i]) {
+				j = 1;
+				break;
+			}
+		}
+		if (j == 0) {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 'n') {
+		if (rate < 0 || rate > 7) {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 'd') {
+		// debug switch
+		if (rate == 0 && power_high == 0 && power_low == 0) {
+			common->txpower_debug = 0;
+			return count;
+		} else if (rate == 1 && power_high == 1 && power_low == 1) {
+			common->txpower_debug = 1;
+			return count;
+		} else {
+			return -EINVAL;
+		}
+	} else if (wifi_mode == 's') {
+		// custom power switch
+		if (rate == 0 && power_high == 0 && power_low == 0) {
+			common->txpower_custom = 0;
+			return count;
+		} else if (rate == 1 && power_high == 1 && power_low == 1) {
+			common->txpower_custom = 1;
+			return count;
+		} else {
+			return -EINVAL;
+		}
+	}
+	else {
+		return -EINVAL;
+	}
+	if (power_high < 0 || power_high > 30 ||
+		power_low < 0  || power_low > 30  ||
+		power_high < power_low) {
+		return -EINVAL;
+	}
+
+	// write to ath_common
+	if (wifi_mode == 'b') {
+		common->txpower_b_high = power_high;
+		common->txpower_b_low = power_low;
+		common->txpower_b_rate = rate;
+	} else if (wifi_mode == 'g') {
+		common->txpower_g_high = power_high;
+		common->txpower_g_low = power_low;
+		common->txpower_g_rate = rate;
+	} else if (wifi_mode == 'n') {
+		common->txpower_n_high = power_high;
+		common->txpower_n_low = power_low;
+		common->txpower_n_rate = rate;
+	}
+
+	// set power
+	mutex_lock(&sc->mutex);
+	ath9k_set_txpower(sc, NULL);
+	mutex_unlock(&sc->mutex);
+
+	return count;
+}
+
+static const struct file_operations fops_txpower_custom = {
+	.read = read_file_txpower_custom,
+	.write = write_file_txpower_custom,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t read_file_antdiv_custom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[256];
+	unsigned int len;
+
+	len = sprintf(buf,
+		"antdiv custom: \n"
+		"Ant. Diversity Enable: %d \n"
+		"Ant. Diversity Control: %d \n",
+		common->ant_custom_en,
+		common->ant_div_ctl
+	);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+/*
+ * original ant div in debugfs is read-only.
+ * this is a dirty hack, ant div will be set in eeprom ops set_board_info
+ * ar9003_eeprom, eeprom_4k
+ *
+ * echo "1:255" > <debugfs>/antdiv_custom
+ * echo "0:0" > <debugfs>/antdiv_custom
+ *
+ * common->ant_custom_en: 0-disable, 1-enable
+ * common->ant_div_ctl:
+ *	bit	|	function
+ * ---------------------------
+ *	7	|	ctl1->ant_fast_div
+ *	6	|	ctl1->main_gaintb
+ *	5	|	ctl1->alt_gaintb
+ *	4	|	ctl1->div_lnadiv
+ *	3:2	|	ctl2->main_lnaconf
+ *	1:0 	|	ctl2->alt_lnaconf
+ */
+static ssize_t write_file_antdiv_custom(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	ssize_t len;
+	int ret, int_en, int_ctl;
+	u8 en = 0, ctl = 0;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%d:%d", &int_en, &int_ctl);
+
+	ctl = (u8)(int_ctl);
+	en = (u8)(int_en);
+
+	// write to ath_common
+	common->ant_div_ctl = ctl;
+	common->ant_custom_en = en;
+
+	// update setting
+	// call IEEE80211_CONF_CHANGE_CHANNEL will update ant. div. setting
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_antdiv_custom = {
+	.read = read_file_antdiv_custom,
+	.write = write_file_antdiv_custom,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t read_file_chanfreq(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[256];
+	unsigned int len;
+
+	len = sprintf(buf,
+		"channel frequency custom: enable %d, freq %d \n",
+		(int)common->chanfreq_en, (int)common->chanfreq
+	);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_chanfreq(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	ssize_t len;
+	int ret, int_en, int_freq;
+	u8 chanfreq_en = 0;
+	u32 chanfreq = 0;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%d:%d", &int_en, &int_freq);
+
+	if (int_en < 0 || int_en > 1 || int_freq < 100 || int_freq > 7000) {
+		return -EINVAL;
+	}
+
+	chanfreq_en = (u8)(int_en);
+	chanfreq = (u32)(int_freq);
+	common->chanfreq_en = chanfreq_en;
+	common->chanfreq = chanfreq;
+
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_chanfreq = {
+	.read = read_file_chanfreq,
+	.write = write_file_chanfreq,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t read_file_mac_hack(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[256];
+	unsigned int len;
+
+	len = sprintf(buf,
+		"mac hack: enable %d, sifs %d, aifs %d, thresh62 %d, slottime %d \n",
+		(int)common->mac_hack_en, (int)common->sifs_man, (int)common->aifs_man,
+		(int)common->thresh62_man, (int)common->slottime_man
+	);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_mac_hack(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	ssize_t len;
+	int ret, int_en, int_sifs, int_aifs, int_thresh62, int_slottime;
+	//u8 mac_hack_en = 0;
+	//u32 sifs_man, aifs_man, slottime_man, thresh62_man;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	ret = sscanf(buf, "%d:%d:%d:%d:%d", &int_en, &int_sifs, 
+			&int_aifs, &int_thresh62, &int_slottime);
+
+	if (	int_en < 0 || int_en > 1 || 
+		int_sifs < 0 || int_sifs > 255 || 
+		int_aifs < 0 || int_aifs > 255 || 
+		int_thresh62 < 0 || int_thresh62 > 255 || 
+		int_slottime < 0 || int_slottime > 255 ) {
+		return -EINVAL;
+	}
+
+	common->mac_hack_en = (u8)int_en;
+	common->sifs_man = (u8)int_sifs;
+	common->aifs_man = (u8)int_aifs;
+	common->thresh62_man = (u8)int_thresh62;
+	common->slottime_man = (u8)int_slottime;
+
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_mac_hack = {
+	.read = read_file_mac_hack,
+	.write = write_file_mac_hack,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 int ath9k_init_debug(struct ath_hw *ah)
 {
@@ -1664,5 +1997,16 @@ int ath9k_init_debug(struct ath_hw *ah)
 	debugfs_create_file("nf_override", 0600,
 			    sc->debug.debugfs_phy, sc, &fops_nf_override);
 
+	debugfs_create_file("txpower_custom", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_txpower_custom);
+
+	debugfs_create_file("antdiv_custom", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_antdiv_custom);
+
+	debugfs_create_file("chanfreq", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+                            sc, &fops_chanfreq);
+
+	debugfs_create_file("mac_hack", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+                            sc, &fops_mac_hack);
 	return 0;
 }
--- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
@@ -582,10 +582,12 @@ static void ath9k_hw_4k_set_txpower(stru
 	struct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);
 	struct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;
 	struct modal_eep_4k_header *pModal = &pEepData->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	int16_t ratesArray[Ar5416RateSize];
 	u8 ht40PowerIncForPdadc = 2;
-	int i;
-
+	int i, j;
+	u8 txp_bl, txp_bh, txp_gl, txp_gh, txp_nl, txp_nh;
+	
 	memset(ratesArray, 0, sizeof(ratesArray));
 
 	if (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)
@@ -609,10 +611,100 @@ static void ath9k_hw_4k_set_txpower(stru
 
 	if (test)
 	    return;
-
-	for (i = 0; i < Ar5416RateSize; i++)
+	
+	for (i = 0; i < Ar5416RateSize; i++) 
 		ratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;
 
+	if (common->txpower_custom == 1) {
+		// Use custom txpower
+		// dBm to reg value
+		txp_bl = common->txpower_b_low * 2;
+		txp_bh = common->txpower_b_high * 2;
+		txp_gl = common->txpower_g_low * 2;
+		txp_gh = common->txpower_g_high * 2;
+		txp_nl = common->txpower_n_low * 2;
+		txp_nh = common->txpower_n_high * 2;
+		
+		// set 802.11b power
+		for (i = rate1l; i <= rateXr; i++) {
+			ratesArray[i] = txp_bl;
+		}
+		switch (common->txpower_b_rate) {
+		case 11:
+			ratesArray[rate11l] = txp_bh;
+			ratesArray[rate11s] = txp_bh;
+		case 5:
+			ratesArray[rate5_5l] = txp_bh;
+			ratesArray[rate5_5s] = txp_bh;
+		case 2:
+			ratesArray[rate2l] = txp_bh;
+			ratesArray[rate2s] = txp_bh;
+		case 1:
+			ratesArray[rate1l] = txp_bh;
+			ratesArray[rateXr] = txp_bh;
+			break;
+		}
+		// 802.11g power
+		for (i = rate6mb; i <= rate54mb; i++) {
+			ratesArray[i] = txp_gl;
+		}
+		switch (common->txpower_g_rate) {
+			case 54: ratesArray[rate54mb] = txp_gh;
+			case 48: ratesArray[rate48mb] = txp_gh;
+			case 36: ratesArray[rate36mb] = txp_gh;
+			case 24: ratesArray[rate24mb] = txp_gh;
+			case 18: ratesArray[rate18mb] = txp_gh;
+			case 12: ratesArray[rate12mb] = txp_gh;
+			case 9: ratesArray[rate9mb]   = txp_gh;
+			case 6: ratesArray[rate6mb]   = txp_gh; break;
+		}
+	
+		// 802.11n HT20 power
+		for (i = rateHt20_0; i <= rateHt20_7; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		switch (common->txpower_n_rate) {
+			case 7: ratesArray[rateHt20_7] = txp_nh;
+			case 6: ratesArray[rateHt20_6] = txp_nh;
+			case 5: ratesArray[rateHt20_5] = txp_nh;
+			case 4: ratesArray[rateHt20_4] = txp_nh;
+			case 3: ratesArray[rateHt20_3] = txp_nh;
+			case 2: ratesArray[rateHt20_2] = txp_nh;
+			case 1: ratesArray[rateHt20_1] = txp_nh;
+			case 0: ratesArray[rateHt20_0] = txp_nh; break;
+		}	
+		// others (ht40): use 802.11n's low power as default
+		for (i = rateHt40_0; i <Ar5416RateSize ; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		// to-do: i don't know the meaning of "DupCck" and "ExtCck" 
+		// but seems that it's sth to do with CCK so i use txpower_b_high
+		// the same as "rateDupOfdm" and "rateExtOfdm"
+		ratesArray[rateDupCck] = txp_bh;
+		ratesArray[rateExtCck] = txp_bh;
+		ratesArray[rateDupOfdm] = txp_gh;
+		ratesArray[rateExtOfdm] = txp_gh;
+		
+		// print to dmesg
+		printk("ath: eeprom_4k: TX Power set: 802.11b: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low);
+		printk("ath: eeprom_4k: TX Power set: 802.11g: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low);
+		printk("ath: eeprom_4k: TX Power set: 802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+				common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low);
+	}
+	
+	// debug: print ratesArray
+	if (common->txpower_debug) {
+		printk("ath: eeprom_4k: TX Power Debug: ratesArray[]: \n");
+		for (j=0; j<(Ar5416RateSize/8)+1; j++) {
+			for (i=0; i<8; i++) {
+				printk("%d ", ratesArray[j*8+i]);
+			}
+			printk("\n");
+		}
+	}
+	
 	ENABLE_REGWRITE_BUFFER(ah);
 
 	/* OFDM power per rate */
@@ -759,6 +851,7 @@ static void ath9k_hw_4k_set_board_values
 	struct modal_eep_4k_header *pModal;
 	struct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;
 	struct base_eep_header_4k *pBase = &eep->baseEepHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	u8 txRxAttenLocal;
 	u8 ob[5], db1[5], db2[5];
 	u8 ant_div_control1, ant_div_control2;
@@ -775,8 +868,16 @@ static void ath9k_hw_4k_set_board_values
 
 	/* Initialize Ant Diversity settings from EEPROM */
 	if (pModal->version >= 3) {
-		ant_div_control1 = pModal->antdiv_ctl1;
-		ant_div_control2 = pModal->antdiv_ctl2;
+		// Custom ant div setting
+		if (1 == common->ant_custom_en) {
+			ant_div_control1 = ((common->ant_div_ctl) & 0xF0) >>4; 
+			ant_div_control2 = (common->ant_div_ctl) & 0x0F;
+			printk("ath9k: eeprom_4k: ant_div custom enabled, ctl1: %d, ctl2: %d\n", ant_div_control1, ant_div_control2);
+		} else {
+			printk("ath9k: eeprom_4k: ant_div custom disabled - use eeprom value, ctl1: %d, ctl2: %d\n", pModal->antdiv_ctl1, pModal->antdiv_ctl2);
+			ant_div_control1 = pModal->antdiv_ctl1;
+			ant_div_control2 = pModal->antdiv_ctl2;
+		}
 
 		regVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);
 		regVal &= (~(AR_PHY_9285_ANT_DIV_CTL_ALL));
@@ -982,10 +1083,18 @@ static void ath9k_hw_4k_set_board_values
 	if (AR_SREV_9271_10(ah))
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,
 			      pModal->txEndToRxOn);
-	REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,
+	if (common->mac_hack_en == 1 && common->thresh62_man != 0) {
+		REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,
+		      common->thresh62_man);
+		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,
+		      common->thresh62_man);
+		printk("eeprom_4k: custom thresh62 set to %d\n", common->thresh62_man);
+	} else {
+		REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,
 		      pModal->thresh62);
-	REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,
+		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,
 		      pModal->thresh62);
+	}
 
 	if (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_DATA_START,
--- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
@@ -711,9 +711,11 @@ static void ath9k_hw_ar9287_set_txpower(
 	struct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);
 	struct ar9287_eeprom *pEepData = &ah->eeprom.map9287;
 	struct modal_eep_ar9287_header *pModal = &pEepData->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	int16_t ratesArray[Ar5416RateSize];
 	u8 ht40PowerIncForPdadc = 2;
-	int i;
+	int i, j;
+	u8 txp_bl, txp_bh, txp_gl, txp_gh, txp_nl, txp_nh;
 
 	memset(ratesArray, 0, sizeof(ratesArray));
 
@@ -740,10 +742,101 @@ static void ath9k_hw_ar9287_set_txpower(
 
 	if (test)
 		return;
-
+		
 	for (i = 0; i < Ar5416RateSize; i++)
 		ratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;
-
+	
+	
+	if (common->txpower_custom == 1) {
+		// Use custom txpower
+		// dBm to reg value
+		txp_bl = common->txpower_b_low * 2;
+		txp_bh = common->txpower_b_high * 2;
+		txp_gl = common->txpower_g_low * 2;
+		txp_gh = common->txpower_g_high * 2;
+		txp_nl = common->txpower_n_low * 2;
+		txp_nh = common->txpower_n_high * 2;
+		
+		// set 802.11b power
+		for (i = rate1l; i <= rateXr; i++) {
+			ratesArray[i] = txp_bl;
+		}
+		switch (common->txpower_b_rate) {
+		case 11:
+			ratesArray[rate11l] = txp_bh;
+			ratesArray[rate11s] = txp_bh;
+		case 5:
+			ratesArray[rate5_5l] = txp_bh;
+			ratesArray[rate5_5s] = txp_bh;
+		case 2:
+			ratesArray[rate2l] = txp_bh;
+			ratesArray[rate2s] = txp_bh;
+		case 1:
+			ratesArray[rate1l] = txp_bh;
+			ratesArray[rateXr] = txp_bh;
+			break;
+		}
+		// 802.11g power
+		for (i = rate6mb; i <= rate54mb; i++) {
+			ratesArray[i] = txp_gl;
+		}
+		switch (common->txpower_g_rate) {
+			case 54: ratesArray[rate54mb] = txp_gh;
+			case 48: ratesArray[rate48mb] = txp_gh;
+			case 36: ratesArray[rate36mb] = txp_gh;
+			case 24: ratesArray[rate24mb] = txp_gh;
+			case 18: ratesArray[rate18mb] = txp_gh;
+			case 12: ratesArray[rate12mb] = txp_gh;
+			case 9: ratesArray[rate9mb]   = txp_gh;
+			case 6: ratesArray[rate6mb]   = txp_gh; break;
+		}
+	
+		// 802.11n HT20 power
+		for (i = rateHt20_0; i <= rateHt20_7; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		switch (common->txpower_n_rate) {
+			case 7: ratesArray[rateHt20_7] = txp_nh;
+			case 6: ratesArray[rateHt20_6] = txp_nh;
+			case 5: ratesArray[rateHt20_5] = txp_nh;
+			case 4: ratesArray[rateHt20_4] = txp_nh;
+			case 3: ratesArray[rateHt20_3] = txp_nh;
+			case 2: ratesArray[rateHt20_2] = txp_nh;
+			case 1: ratesArray[rateHt20_1] = txp_nh;
+			case 0: ratesArray[rateHt20_0] = txp_nh; break;
+		}	
+		// others (ht40): use 802.11n's low power as default
+		for (i = rateHt40_0; i <Ar5416RateSize ; i++) {
+			ratesArray[i] = txp_nl;
+		}
+		// to-do: i don't know the meaning of "DupCck" and "ExtCck" 
+		// but seems that it's sth to do with CCK so i use txpower_b_high
+		// the same as "rateDupOfdm" and "rateExtOfdm"
+		ratesArray[rateDupCck] = txp_bh;
+		ratesArray[rateExtCck] = txp_bh;
+		ratesArray[rateDupOfdm] = txp_gh;
+		ratesArray[rateExtOfdm] = txp_gh;
+		
+		// print to dmesg
+		printk("ath: eeprom_9287: TX Power set: 802.11b: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_b_rate, common->txpower_b_high, common->txpower_b_low);
+		printk("ath: eeprom_9287: TX Power set: 802.11g: rate %d, high %d dBm, low %d dBm\n", 
+				common->txpower_g_rate, common->txpower_g_high, common->txpower_g_low);
+		printk("ath: eeprom_9287: TX Power set: 802.11n: MCS %d, high %d dBm, low %d dBm\n", 
+				common->txpower_n_rate, common->txpower_n_high, common->txpower_n_low);
+	}
+	
+	// debug: print ratesArray
+	if (common->txpower_debug) {
+		printk("ath: eeprom_9287: TX Power Debug: ratesArray[]: \n");
+		for (j=0; j<(Ar5416RateSize/8)+1; j++) {
+			for (i=0; i<8; i++) {
+				printk("%d ", ratesArray[j*8+i]);
+			}
+			printk("\n");
+		}
+	}
+	
 	ENABLE_REGWRITE_BUFFER(ah);
 
 	/* OFDM power per rate */
@@ -852,6 +945,7 @@ static void ath9k_hw_ar9287_set_board_va
 {
 	struct ar9287_eeprom *eep = &ah->eeprom.map9287;
 	struct modal_eep_ar9287_header *pModal = &eep->modalHeader;
+	struct ath_common *common = ath9k_hw_common(ah);
 	u32 regChainOffset, regval;
 	u8 txRxAttenLocal;
 	int i;
@@ -910,12 +1004,18 @@ static void ath9k_hw_ar9287_set_board_va
 
 	REG_RMW_FIELD(ah, AR_PHY_RF_CTL3,
 		      AR_PHY_TX_END_TO_A2_RX_ON, pModal->txEndToRxOn);
-
-	REG_RMW_FIELD(ah, AR_PHY_CCA,
+	if (common->mac_hack_en == 1 && common->thresh62_man != 0) {
+		REG_RMW_FIELD(ah, AR_PHY_CCA,
+		      AR9280_PHY_CCA_THRESH62, common->thresh62_man);
+		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,
+		      AR_PHY_EXT_CCA0_THRESH62, common->thresh62_man);
+		printk("eeprom_9287: custom thresh62 set %d\n", common->thresh62_man);
+	} else {
+		REG_RMW_FIELD(ah, AR_PHY_CCA,
 		      AR9280_PHY_CCA_THRESH62, pModal->thresh62);
-	REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,
+		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,
 		      AR_PHY_EXT_CCA0_THRESH62, pModal->thresh62);
-
+	}
 	regval = REG_READ(ah, AR9287_AN_RF2G3_CH0);
 	regval &= ~(AR9287_AN_RF2G3_DB1 |
 		    AR9287_AN_RF2G3_DB2 |
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -62,6 +62,13 @@ static void ath9k_hw_set_clockrate(struc
 			clockrate /= 2;
 		if (IS_CHAN_QUARTER_RATE(chan))
 			clockrate /= 4;
+		if (IS_CHAN_2M5_RATE(chan))
+                        clockrate /= 8;
+                if (IS_CHAN_12M5_RATE(chan))
+                        clockrate = (clockrate * 5) / 8;
+                if (IS_CHAN_7M_RATE(chan))
+                        clockrate = (((clockrate / 2)*5)/7);
+
 	}
 
 	common->clockrate = clockrate;
@@ -104,6 +111,12 @@ void ath9k_hw_synth_delay(struct ath_hw
 		hw_delay *= 2;
 	else if (IS_CHAN_QUARTER_RATE(chan))
 		hw_delay *= 4;
+	else if (IS_CHAN_2M5_RATE(chan))
+                hw_delay *= 8;
+	else if (IS_CHAN_12M5_RATE(chan))
+                hw_delay = (hw_delay *8)/5;
+	else if (IS_CHAN_7M_RATE(chan))
+                hw_delay = ((hw_delay *2)*7)/5;
 
 	udelay(hw_delay + BASE_ACTIVATE_DELAY);
 }
@@ -200,7 +213,34 @@ u16 ath9k_hw_computetxtime(struct ath_hw
 			txTime = OFDM_SIFS_TIME_HALF +
 				OFDM_PREAMBLE_TIME_HALF
 				+ (numSymbols * OFDM_SYMBOL_TIME_HALF);
-		} else {
+		} else if (ah->curchan &&
+                           IS_CHAN_2M5_RATE(ah->curchan)) {
+                        bitsPerSymbol =
+                                ((kbps >> 3) * OFDM_SYMBOL_TIME_2M5) / 1000;
+                        numBits = OFDM_PLCP_BITS + (frameLen << 3);
+                        numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
+                        txTime = OFDM_SIFS_TIME_2M5 +
+                                OFDM_PREAMBLE_TIME_2M5
+                                + (numSymbols * OFDM_SYMBOL_TIME_2M5);
+                } else if (ah->curchan &&
+                           IS_CHAN_7M_RATE(ah->curchan)) {
+                        bitsPerSymbol =
+                                (( ((kbps>>1) *5)/7) * OFDM_SYMBOL_TIME_7M) / 1000;
+                        numBits = OFDM_PLCP_BITS + (frameLen << 3);
+                        numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
+                        txTime = OFDM_SIFS_TIME_7M +
+                                OFDM_PREAMBLE_TIME_7M
+                                + (numSymbols * OFDM_SYMBOL_TIME_7M);
+                } else if (ah->curchan &&
+                           IS_CHAN_12M5_RATE(ah->curchan)) {
+                        bitsPerSymbol =
+                                (((kbps*5)/8) * OFDM_SYMBOL_TIME_12M5) / 1000;
+                        numBits = OFDM_PLCP_BITS + (frameLen << 3);
+                        numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
+                        txTime = OFDM_SIFS_TIME_12M5 +
+                                OFDM_PREAMBLE_TIME_12M5
+                                + (numSymbols * OFDM_SYMBOL_TIME_12M5);
+                } else {
 			bitsPerSymbol = (kbps * OFDM_SYMBOL_TIME) / 1000;
 			numBits = OFDM_PLCP_BITS + (frameLen << 3);
 			numSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);
@@ -1092,7 +1132,44 @@ void ath9k_hw_init_global_settings(struc
 		ack_offset = 32;
 		ack_shift = 1;
 		slottime = 21;
-	} else {
+	} else if (IS_CHAN_2M5_RATE(chan)) {
+		// Note: I don't know how to set these args
+		// just *2 and hope it will work
+		eifs = 680;	
+		rx_lat = (rx_lat * 8) - 1;
+		tx_lat *= 8;
+		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
+		    tx_lat += 44;
+
+		sifstime = 128;
+		ack_offset = 64;
+		ack_shift = 0;	// see ar9271 datasheet - 2M5 chanbw when ACK_SHIFT=0
+		slottime = 36;	// hope it will work
+	} else if (IS_CHAN_12M5_RATE(chan)) {
+                // Note: I don't know how to set these args
+                eifs = 140;
+                rx_lat = ((rx_lat * 8) / 5) - 1;
+                tx_lat = (tx_lat *8) / 5;
+                if (IS_CHAN_A_FAST_CLOCK(ah, chan))
+                    tx_lat += 8;
+
+                sifstime = 25;
+                ack_offset = 12;
+                ack_shift = 3;
+                slottime = 10;
+        } else if (IS_CHAN_7M_RATE(chan)) {
+                // Note: I don't know how to set these args
+                eifs = 250;
+                rx_lat = ((rx_lat * 14)/5) - 1;
+                tx_lat = ((tx_lat * 14) /5);
+                if (IS_CHAN_A_FAST_CLOCK(ah, chan))
+                    tx_lat += 18;
+
+                sifstime = 45;
+                ack_offset = 23;
+                ack_shift = 1;
+                slottime = 18;
+        } else {
 		if (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {
 			eifs = AR_D_GBL_IFS_EIFS_ASYNC_FIFO;
 			reg = AR_USEC_ASYNC_FIFO;
@@ -1107,6 +1184,13 @@ void ath9k_hw_init_global_settings(struc
 		slottime = ah->slottime;
 	}
 
+	// wbc mac hacks
+	if (common->mac_hack_en == 1) {
+		sifstime = (common->sifs_man == 0)? sifstime: common->sifs_man;
+		slottime = (common->slottime_man == 0)? slottime: common->slottime_man;
+		printk("ath9k_hw: mac hack enabled, sifs %d, slottime %d", sifstime, slottime);
+	}
+
 	/* As defined by IEEE 802.11-2007 17.3.8.6 */
 	slottime += 3 * ah->coverage_class;
 	acktimeout = slottime + sifstime + ack_offset;
@@ -1120,7 +1204,9 @@ void ath9k_hw_init_global_settings(struc
 	 * timeout issues in other cases as well.
 	 */
 	if (IS_CHAN_2GHZ(chan) &&
-	    !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)) {
+	    !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)
+		&& !IS_CHAN_12M5_RATE(chan) && !IS_CHAN_7M_RATE(chan)
+		&& !IS_CHAN_2M5_RATE(chan)) {
 		acktimeout += 64 - sifstime - ah->slottime;
 		ctstimeout += 48 - sifstime - ah->slottime;
 	}
@@ -1147,7 +1233,9 @@ void ath9k_hw_init_global_settings(struc
 		SM(tx_lat, AR_USEC_TX_LAT),
 		AR_USEC_TX_LAT | AR_USEC_RX_LAT | AR_USEC_USEC);
 
-	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan) 
+		|| IS_CHAN_2M5_RATE(chan) || IS_CHAN_7M_RATE(chan)
+		|| IS_CHAN_12M5_RATE(chan) )
 		REG_RMW(ah, AR_TXSIFS,
 			sifstime | SM(ack_shift, AR_TXSIFS_ACK_SHIFT),
 			(AR_TXSIFS_TIME | AR_TXSIFS_ACK_SHIFT));
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -459,10 +459,16 @@ struct ath9k_channel {
 #define CHANNEL_HT		BIT(3)
 #define CHANNEL_HT40PLUS	BIT(4)
 #define CHANNEL_HT40MINUS	BIT(5)
+#define CHANNEL_2M5		BIT(6)
+#define CHANNEL_7M		BIT(7)
+#define CHANNEL_12M5		BIT(8)
 
 #define IS_CHAN_5GHZ(_c) (!!((_c)->channelFlags & CHANNEL_5GHZ))
 #define IS_CHAN_2GHZ(_c) (!IS_CHAN_5GHZ(_c))
 
+#define IS_CHAN_2M5_RATE(_c) (!!((_c)->channelFlags & CHANNEL_2M5))
+#define IS_CHAN_7M_RATE(_c) (!!((_c)->channelFlags & CHANNEL_7M))
+#define IS_CHAN_12M5_RATE(_c) (!!((_c)->channelFlags & CHANNEL_12M5))
 #define IS_CHAN_HALF_RATE(_c) (!!((_c)->channelFlags & CHANNEL_HALF))
 #define IS_CHAN_QUARTER_RATE(_c) (!!((_c)->channelFlags & CHANNEL_QUARTER))
 #define IS_CHAN_A_FAST_CLOCK(_ah, _c)			\
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -141,6 +141,13 @@ void ath9k_hw_abort_tx_dma(struct ath_hw
 			maxdelay *= 2;
 		else if (IS_CHAN_QUARTER_RATE(ah->curchan))
 			maxdelay *= 4;
+		else if (IS_CHAN_2M5_RATE(ah->curchan))
+			maxdelay *= 8;
+		else if (IS_CHAN_12M5_RATE(ah->curchan))
+                        maxdelay = (maxdelay *8)/5;
+		else if (IS_CHAN_7M_RATE(ah->curchan))
+                        maxdelay = (maxdelay *14) /5;
+
 	}
 
 	REG_WRITE(ah, AR_Q_TXD, AR_Q_TXD_M);
@@ -213,10 +220,16 @@ bool ath9k_hw_set_txq_props(struct ath_h
 	qi->tqi_subtype = qinfo->tqi_subtype;
 	qi->tqi_qflags = qinfo->tqi_qflags;
 	qi->tqi_priority = qinfo->tqi_priority;
-	if (qinfo->tqi_aifs != ATH9K_TXQ_USEDEFAULT)
+	if (qinfo->tqi_aifs != ATH9K_TXQ_USEDEFAULT) {
 		qi->tqi_aifs = min(qinfo->tqi_aifs, 255U);
-	else
-		qi->tqi_aifs = INIT_AIFS;
+	} else {
+		if (common->mac_hack_en == 1) {
+			qi->tqi_aifs = common->aifs_man;
+			printk("ath9k_mac: custom aifs set to %d\n", qi->tqi_aifs);
+		} else {
+			qi->tqi_aifs = 2;	// default
+		}
+	}
 	if (qinfo->tqi_cwmin != ATH9K_TXQ_USEDEFAULT) {
 		cw = min(qinfo->tqi_cwmin, 1024U);
 		qi->tqi_cwmin = 1;
--- a/drivers/net/wireless/ath/ath9k/common.c
+++ b/drivers/net/wireless/ath/ath9k/common.c
@@ -184,6 +184,12 @@ int ath9k_cmn_process_rate(struct ath_co
 		rxs->bw = RATE_INFO_BW_5;
 	else if (IS_CHAN_HALF_RATE(ah->curchan))
 		rxs->bw = RATE_INFO_BW_10;
+	else if (IS_CHAN_2M5_RATE(ah->curchan))
+                rxs->bw = RATE_INFO_BW_2M5;
+	else if (IS_CHAN_12M5_RATE(ah->curchan))
+                rxs->bw = RATE_INFO_BW_12M5;
+	else if (IS_CHAN_7M_RATE(ah->curchan))
+                rxs->bw = RATE_INFO_BW_7M;
 
 	if (rx_stats->rs_rate & 0x80) {
 		/* HT rate */
@@ -312,21 +318,39 @@ static void ath9k_cmn_update_ichannel(st
 		flags |= CHANNEL_5GHZ;
 
 	switch (common->chan_bw) {
+	case 2:
+		width = NL80211_CHAN_WIDTH_2M5;
+		break;
 	case 5:
 		width = NL80211_CHAN_WIDTH_5;
 		break;
+	case 7:
+		width = NL80211_CHAN_WIDTH_7;
+		break;
 	case 10:
 		width = NL80211_CHAN_WIDTH_10;
 		break;
+	case 12:
+		width = NL80211_CHAN_WIDTH_12M5;
+		break;
 	default:
 		width = chandef->width;
 		break;
 	}
 
 	switch (width) {
+	case NL80211_CHAN_WIDTH_2M5:
+		flags |= CHANNEL_2M5;
+		break;
 	case NL80211_CHAN_WIDTH_5:
 		flags |= CHANNEL_QUARTER;
 		break;
+	case NL80211_CHAN_WIDTH_12M5:
+                flags |= CHANNEL_12M5;
+                break;
+        case NL80211_CHAN_WIDTH_7:
+                flags |= CHANNEL_7M;
+                break;
 	case NL80211_CHAN_WIDTH_10:
 		flags |= CHANNEL_HALF;
 		break;
--- a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
@@ -398,6 +398,50 @@ static const struct file_operations fops
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_chanbw(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath9k_htc_priv *priv = file->private_data;
+	struct ath_common *common = ath9k_hw_common(priv->ah);
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_chanbw(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath9k_htc_priv *priv = file->private_data;
+	struct ath_common *common = ath9k_hw_common(priv->ah);
+	unsigned long chan_bw;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &chan_bw))
+		return -EINVAL;
+
+	common->chan_bw = chan_bw;
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_htc_ops.config(priv->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_chanbw = {
+	.read = read_file_chanbw,
+	.write = write_file_chanbw,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
 /* Ethtool support for get-stats */
 #define AMKSTR(nm) #nm "_BE", #nm "_BK", #nm "_VI", #nm "_VO"
 static const char ath9k_htc_gstrings_stats[][ETH_GSTRING_LEN] = {
@@ -516,6 +560,8 @@ int ath9k_htc_init_debug(struct ath_hw *
 			    priv, &fops_queue);
 	debugfs_create_file("debug", 0600, priv->debug.debugfs_phy,
 			    priv, &fops_debug);
+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, priv->debug.debugfs_phy,
+			    priv, &fops_chanbw);
 
 	ath9k_cmn_debug_base_eeprom(priv->debug.debugfs_phy, priv->ah);
 	ath9k_cmn_debug_modal_eeprom(priv->debug.debugfs_phy, priv->ah);
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -4073,6 +4073,9 @@ enum nl80211_channel_type {
  *	attribute must be provided as well
  * @NL80211_CHAN_WIDTH_5: 5 MHz OFDM channel
  * @NL80211_CHAN_WIDTH_10: 10 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_2M5: 2.5 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_12M5: 12.5 MHz OFDM channel
+ * @NL80211_CHAN_WIDTH_7: 7 MHz OFDM channel
  */
 enum nl80211_chan_width {
 	NL80211_CHAN_WIDTH_20_NOHT,
@@ -4083,6 +4086,9 @@ enum nl80211_chan_width {
 	NL80211_CHAN_WIDTH_160,
 	NL80211_CHAN_WIDTH_5,
 	NL80211_CHAN_WIDTH_10,
+	NL80211_CHAN_WIDTH_2M5,
+	NL80211_CHAN_WIDTH_12M5,
+	NL80211_CHAN_WIDTH_7,
 };
 
 /**
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -192,8 +192,13 @@ static int ar5008_hw_set_channel(struct
 	u16 freq;
 	struct chan_centers centers;
 
-	ath9k_hw_get_channel_centers(ah, chan, &centers);
-	freq = centers.synth_center;
+	// custom chanfreq
+	if (common->chanfreq_en == 1) {
+		freq = (u16)common->chanfreq;
+	} else { 	
+		ath9k_hw_get_channel_centers(ah, chan, &centers);
+		freq = centers.synth_center;
+	}
 
 	if (freq < 4800) {
 		u32 txctl;
@@ -845,6 +850,12 @@ static void ar5008_hw_set_delta_slope(st
 		clockMhzScaled = clockMhzScaled >> 1;
 	else if (IS_CHAN_QUARTER_RATE(chan))
 		clockMhzScaled = clockMhzScaled >> 2;
+	else if (IS_CHAN_2M5_RATE(chan))
+		clockMhzScaled = clockMhzScaled >> 3;
+	else if (IS_CHAN_7M_RATE(chan))
+		clockMhzScaled = (clockMhzScaled*5) / 14;
+	else if (IS_CHAN_12M5_RATE(chan))
+		clockMhzScaled = (clockMhzScaled*5) / 8;
 
 	ath9k_hw_get_channel_centers(ah, chan, &centers);
 	coef_scaled = clockMhzScaled / centers.synth_center;
@@ -905,6 +916,18 @@ static u32 ar9160_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+		pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);		// needs test
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9160_PLL_REFDIV);
+	} else if (chan && IS_CHAN_7M_RATE(chan)) {
+		pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9160_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+		pll |= SM(0x8, AR_RTC_9160_PLL_REFDIV);
+	}
 
 	if (chan && IS_CHAN_5GHZ(chan))
 		pll |= SM(0x50, AR_RTC_9160_PLL_DIV);
@@ -921,10 +944,17 @@ static u32 ar5008_hw_compute_pll_control
 
 	pll = AR_RTC_PLL_REFDIV_5 | AR_RTC_PLL_DIV2;
 
-	if (chan && IS_CHAN_HALF_RATE(chan))
+	if (chan && (IS_CHAN_HALF_RATE(chan) || IS_CHAN_7M_RATE(chan) 
+		|| IS_CHAN_12M5_RATE(chan)))
 		pll |= SM(0x1, AR_RTC_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_PLL_CLKSEL);
+	else if (chan && IS_CHAN_2M5_RATE(chan))
+                pll |= SM(0x2, AR_RTC_PLL_CLKSEL);
+
+	// seems that we can't set ar5008 ref_div to 10? 
+	// set 2m5 to 5, 7m/12m5 to 10m
+	// needs test
 
 	if (chan && IS_CHAN_5GHZ(chan))
 		pll |= SM(0xa, AR_RTC_PLL_DIV);
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.c
@@ -69,9 +69,14 @@ static int ar9002_hw_set_channel(struct
 	u32 freq, ndiv, channelSel = 0, channelFrac = 0, reg32 = 0;
 	struct chan_centers centers;
 	u32 refDivA = 24;
+	struct ath_common *common = ath9k_hw_common(ah);
 
-	ath9k_hw_get_channel_centers(ah, chan, &centers);
-	freq = centers.synth_center;
+	if (common->chanfreq_en == 1) {
+		freq = (u32)common->chanfreq;
+	} else {
+		ath9k_hw_get_channel_centers(ah, chan, &centers);
+		freq = centers.synth_center;
+	}
 
 	reg32 = REG_READ(ah, AR_PHY_SYNTH_CONTROL);
 	reg32 &= 0xc0000000;
@@ -111,7 +116,11 @@ static int ar9002_hw_set_channel(struct
 
 		switch (ah->eep_ops->get_eeprom(ah, EEP_FRAC_N_5G)) {
 		case 0:
-			if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+			if (IS_CHAN_HALF_RATE(chan) || 
+				IS_CHAN_QUARTER_RATE(chan) || 
+				IS_CHAN_2M5_RATE(chan) ||
+				IS_CHAN_7M_RATE(chan) || 
+                                IS_CHAN_12M5_RATE(chan) )
 				aModeRefSel = 0;
 			else if ((freq % 20) == 0)
 				aModeRefSel = 3;
@@ -324,7 +333,22 @@ static u32 ar9002_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
-
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+                pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
+		// Note: experimental, needs test
+		pll &= (~(AR_RTC_9160_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9160_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+                //pll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);
+                // Note: experimental, needs test
+                pll &= (~(AR_RTC_9160_PLL_REFDIV));
+                pll |= SM(0x8, AR_RTC_9160_PLL_REFDIV);
+        } else if (chan && IS_CHAN_7M_RATE(chan)) {
+                pll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);
+                // Note: experimental, needs test
+                pll &= (~(AR_RTC_9160_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9160_PLL_REFDIV);
+        }
 	return pll;
 }
 
--- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
@@ -1451,7 +1451,9 @@ static bool ar9003_hw_init_cal_pcoem(str
 		}
 	}
 
-	if ((IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan)) ||
+	if ((IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan)
+		|| IS_CHAN_2M5_RATE(chan)) || IS_CHAN_12M5_RATE(chan)
+		|| IS_CHAN_7M_RATE(chan) ||
 	    !(ah->enabled_cals & TX_IQ_CAL))
 		goto skip_tx_iqcal;
 
@@ -1596,7 +1598,9 @@ static bool ar9003_hw_init_cal_soc(struc
 		run_agc_cal = true;
 	}
 
-	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan)
+		|| IS_CHAN_2M5_RATE(chan) || IS_CHAN_12M5_RATE(chan)
+		|| IS_CHAN_7M_RATE(chan))
 		goto skip_tx_iqcal;
 
 	/* Do Tx IQ Calibration */
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -138,9 +138,14 @@ static int ar9003_hw_set_channel(struct
 	u32 freq, chan_frac, div, channelSel = 0, reg32 = 0;
 	struct chan_centers centers;
 	int loadSynthChannel;
+	struct ath_common *common = ath9k_hw_common(ah);
 
-	ath9k_hw_get_channel_centers(ah, chan, &centers);
-	freq = centers.synth_center;
+	if (common->chanfreq_en == 1) {
+		freq = (u32)common->chanfreq;
+	} else {
+		ath9k_hw_get_channel_centers(ah, chan, &centers);
+		freq = centers.synth_center;
+	}
 
 	if (freq < 4800) {     /* 2 GHz, fractional mode */
 		if (AR_SREV_9330(ah)) {
@@ -597,7 +602,19 @@ static u32 ar9003_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9300_SOC_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9300_SOC_PLL_CLKSEL);
-
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+                pll |= SM(0x2, AR_RTC_9300_SOC_PLL_CLKSEL);		// needs test
+		pll &= (~(AR_RTC_9300_SOC_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9300_SOC_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+                //pll |= SM(0x2, AR_RTC_9300_SOC_PLL_CLKSEL);             // need$
+                pll &= (~(AR_RTC_9300_SOC_PLL_REFDIV));
+                pll |= SM(0x8, AR_RTC_9300_SOC_PLL_REFDIV);
+        } else if (chan && IS_CHAN_7M_RATE(chan)) {
+                pll |= SM(0x1, AR_RTC_9300_SOC_PLL_CLKSEL);             // need$
+                pll &= (~(AR_RTC_9300_SOC_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9300_SOC_PLL_REFDIV);
+        }
 	pll |= SM(0x2c, AR_RTC_9300_SOC_PLL_DIV_INT);
 
 	return pll;
@@ -614,6 +631,19 @@ static u32 ar9003_hw_compute_pll_control
 		pll |= SM(0x1, AR_RTC_9300_PLL_CLKSEL);
 	else if (chan && IS_CHAN_QUARTER_RATE(chan))
 		pll |= SM(0x2, AR_RTC_9300_PLL_CLKSEL);
+	else if (chan && IS_CHAN_2M5_RATE(chan)) {
+                pll |= SM(0x2, AR_RTC_9300_PLL_CLKSEL);		// needs test
+		pll &= (~(AR_RTC_9300_PLL_REFDIV));
+		pll |= SM(0xA, AR_RTC_9300_PLL_REFDIV);
+	} else if (chan && IS_CHAN_12M5_RATE(chan)) {
+                //pll |= SM(0x3, AR_RTC_9300_PLL_CLKSEL);         // needs test
+                pll &= (~(AR_RTC_9300_PLL_REFDIV));
+                pll |= SM(0x8, AR_RTC_9300_PLL_REFDIV);
+        } else if (chan && IS_CHAN_7M_RATE(chan)) {
+                pll |= SM(0x1, AR_RTC_9300_PLL_CLKSEL);         // needs test
+                pll &= (~(AR_RTC_9300_PLL_REFDIV));
+                pll |= SM(0x7, AR_RTC_9300_PLL_REFDIV);
+        }
 
 	pll |= SM(0x2c, AR_RTC_9300_PLL_DIV);
 
@@ -996,7 +1026,9 @@ static void ar9003_hw_set_rfmode(struct
 	if (IS_CHAN_A_FAST_CLOCK(ah, chan))
 		rfMode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);
 
-	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))
+	if (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan) 
+		|| IS_CHAN_2M5_RATE(chan) || IS_CHAN_12M5_RATE(chan)
+		|| IS_CHAN_7M_RATE(chan) )
 		REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,
 			      AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW, 3);
 
@@ -1023,6 +1055,12 @@ static void ar9003_hw_set_delta_slope(st
 		clockMhzScaled = clockMhzScaled >> 1;
 	else if (IS_CHAN_QUARTER_RATE(chan))
 		clockMhzScaled = clockMhzScaled >> 2;
+	else if (IS_CHAN_2M5_RATE(chan))
+                clockMhzScaled = clockMhzScaled >> 3;
+	else if (IS_CHAN_12M5_RATE(chan))
+                clockMhzScaled = (clockMhzScaled*5) / 8;
+	else if (IS_CHAN_7M_RATE(chan))
+                clockMhzScaled = (clockMhzScaled*5) / 14;
 
 	/*
 	 * ALGO -> coef = 1e8/fcarrier*fclock/40;
--- a/drivers/net/wireless/ath/ath9k/dynack.c
+++ b/drivers/net/wireless/ath/ath9k/dynack.c
@@ -53,6 +53,12 @@ static inline u32 ath_dynack_get_sifs(st
 			sifs = OFDM_SIFS_TIME_QUARTER;
 		else if (IS_CHAN_HALF_RATE(ah->curchan))
 			sifs = OFDM_SIFS_TIME_HALF;
+		else if (IS_CHAN_2M5_RATE(ah->curchan))
+                        sifs = OFDM_SIFS_TIME_2M5;
+		else if (IS_CHAN_12M5_RATE(ah->curchan))
+                        sifs = OFDM_SIFS_TIME_12M5;
+		else if (IS_CHAN_7M_RATE(ah->curchan))
+                        sifs = OFDM_SIFS_TIME_7M;
 		else
 			sifs = OFDM_SIFS_TIME;
 	}
--- a/drivers/net/wireless/ath/ath9k/mac.h
+++ b/drivers/net/wireless/ath/ath9k/mac.h
@@ -57,6 +57,21 @@
 #define OFDM_PLCP_BITS_QUARTER      22
 #define OFDM_SYMBOL_TIME_QUARTER    16
 
+#define OFDM_SIFS_TIME_2M5     	128
+#define OFDM_PREAMBLE_TIME_2M5  160
+#define OFDM_PLCP_BITS_2M5      22
+#define OFDM_SYMBOL_TIME_2M5    32
+
+#define OFDM_SIFS_TIME_12M5      25
+#define OFDM_PREAMBLE_TIME_12M5  32
+#define OFDM_PLCP_BITS_12M5      22
+#define OFDM_SYMBOL_TIME_12M5    7
+
+#define OFDM_SIFS_TIME_7M      46
+#define OFDM_PREAMBLE_TIME_7M  57
+#define OFDM_PLCP_BITS_7M      22
+#define OFDM_SYMBOL_TIME_7M    12
+
 #define INIT_AIFS       2
 #define INIT_CWMIN      15
 #define INIT_CWMIN_11B  31
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -1108,7 +1108,10 @@ enum rate_info_flags {
  *
  * Used by the driver to indicate the rate bandwidth.
  *
+ * @RATE_INFO_BW_2M5: 2.5 MHz bandwidth
  * @RATE_INFO_BW_5: 5 MHz bandwidth
+ * @RATE_INFO_BW_7M: 7 MHz bandwidth
+ * @RATE_INFO_BW_12M5: 12.5 MHz bandwidth
  * @RATE_INFO_BW_10: 10 MHz bandwidth
  * @RATE_INFO_BW_20: 20 MHz bandwidth
  * @RATE_INFO_BW_40: 40 MHz bandwidth
@@ -1124,6 +1127,9 @@ enum rate_info_bw {
 	RATE_INFO_BW_80,
 	RATE_INFO_BW_160,
 	RATE_INFO_BW_HE_RU,
+	RATE_INFO_BW_2M5,
+	RATE_INFO_BW_7M,
+	RATE_INFO_BW_12M5,
 };
 
 /**
